{"version":3,"sources":["serviceWorker.ts","components/babylon/BabylonScene.tsx","components/babylon/util/BasicUtils.tsx","components/babylon/util/MaterialUtils.tsx","components/babylon/util/LoaderUtils.tsx","components/babylon/helper/HighPerformanceQueue.tsx","components/babylon/node/WorkbenchNode.tsx","page/View/Scene.tsx","index.tsx"],"names":["Boolean","window","location","hostname","match","BabylonScene","scene","engine","canvas","sceneMountReturn","onResizeWindow","_this","resize","onCanvasLoaded","c","width","parentElement","offsetWidth","height","offsetHeight","resizeEvents","i","length","this","BABYLON","props","engineOptions","adaptToDeviceRatio","sceneOptions","onSceneMount","console","error","addEventListener","onBeforeUnload","_event","removeEventListener","dispose","react","ref","React","BasicUtils","range","s","Math","floor","random","name","container","directDescendantsOnly","children","getChildTransformNodes","index","indexOf","firstName","substring","lastName","child","findFirstChild","node","bounds","x","min","max","y","z","depth","firstChildIsMesh","getBoundingInfo","minimum","maximum","getChildMeshes","m","isEnabled","abs","root","parent","copy","createInstance","clone","element","id","undefined","r","g","b","poly","point","j","l","MaterialUtils","Scene","CURRENT_SCENE","wood","wAng","PI","uScale","metal","level","laptop","carpet","vScale","material","albedoColor","color","metallic","roughness","backFaceCulling","clearCoat","intensity","indexOfRefraction","specularIntensity","directIntensity","enableSpecularAntiAliasing","albedoTexture","LoaderUtils","loadedNode","isDisposed","setEnabled","loading","clear","loaded","obj","callback","has","model","get","getBounds","push","set","scaling","defaultSettings","rotation","pluginExtension","log","axios","withCredentials","headers","jwt","localStorage","getItem","then","response","text","JSON","stringify","data","materialsToDispose","Map","ImportMesh","_meshes","_particleSystems","_skeletons","_animationGroups","position","Zero","cullingStrategy","CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY","materials","uniqueId","forEach","_value","_key","t","setTimeout","asyncCallbacks","_loop","asyncCallback","ar","delete","catch","reason","_loop2","size","HighPerformanceQueue","f","map","queue","call","shift","isRunning","e","Array","WorkbenchNode","Object","classCallCheck","possibleConstructorReturn","getPrototypeOf","bake","_this2","ground","CreateGround","getMaterialByName","table","plateScale","legScale","frameScale","meshes","facesUv","options","faceUV","wrap","plate","CreateBox","leg0","leg1","leg2","leg3","frameOut","hole","fCSG","FromMesh","hCSG","chair","frame","subtract","toMesh","MergeMeshes","newMeshes","rotationQuaternion","lapScale","laptopMat","lapBase","lapScreen","sin","helmet","lamp","light","shadowGenerator","getShadowMap","renderList","mesh","node2","node3","receiveShadows","usePoissonSampling","prototype","_scene","_initialized","_babylonScene","clearColor","ambientColor","fogMode","FOGMODE_LINEAR","fogColor","fogStart","fogEnd","shadowsEnabled","camera","setPosition","lowerBetaLimit","upperBetaLimit","lowerRadiusLimit","cameraRotation","layerMask","activeCamera","lightShadow","lightmapMode","LIGHTMAP_SHADOWSONLY","lightBack","useBlurExponentialShadowMap","blurScale","initialize","renderFirstTime","render","runRenderLoop","document","hasFocus","attachControl","onDispose","key","endsWith","enableEdgesRendering","debugLayer","show","className","BabylonScene_BabylonScene","preserveDrawingBuffer","stencil","useClonedMeshMap","ReactDOM","react_default","a","createElement","Scene_Scene","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.d38dd7b8.chunk.js","sourcesContent":["// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import * as React from 'react';\nimport * as BABYLON from 'babylonjs';\n\nexport type SceneEventArgs = {\n  engine: BABYLON.Engine;\n  scene: BABYLON.Scene;\n  canvas: HTMLCanvasElement;\n};\n\nexport type SceneProps = {\n  engineOptions?: BABYLON.EngineOptions;\n  sceneOptions?: BABYLON.SceneOptions;\n  adaptToDeviceRatio?: boolean;\n  onSceneMount?: (args: SceneEventArgs) => SceneMountReturn;\n};\n\nexport type SceneMountReturn = {\n  resizeEvents?: Array<() => void>;\n};\n\nexport default class BabylonScene extends React.Component<SceneProps & React.HTMLAttributes<HTMLCanvasElement>, {}> {\n  private scene: BABYLON.Scene;\n  private engine: BABYLON.Engine;\n  private canvas: HTMLCanvasElement;\n\n  private sceneMountReturn: SceneMountReturn;\n\n  onResizeWindow = () => {\n    if (this.engine) {\n      this.engine.resize();\n      this.resize();\n    }\n  };\n\n  componentDidMount() {\n    // Produce new shit\n    this.engine = new BABYLON.Engine(this.canvas, true, this.props.engineOptions, this.props.adaptToDeviceRatio);\n\n    this.scene = new BABYLON.Scene(this.engine, this.props.sceneOptions);\n\n    if (typeof this.props.onSceneMount === 'function') {\n      this.sceneMountReturn = this.props.onSceneMount({\n        scene: this.scene,\n        engine: this.engine,\n        canvas: this.canvas\n      });\n    } else {\n      console.error('onSceneMount function not available');\n    }\n\n    // Resize the babylon engine when the window is resized\n    window.addEventListener('resize', this.onResizeWindow);\n\n    // Clean up old shit\n    window['_active_scene'] = this.scene;\n    window['_active_engine'] = this.engine;\n    window.addEventListener('beforeunload', this.onBeforeUnload);\n  }\n\n  onBeforeUnload(_event: BeforeUnloadEvent) {\n    window.removeEventListener('resize', this.onResizeWindow);\n    const scene = window['_active_scene'];\n    const engine = window['_active_engine'];\n    if (scene && scene instanceof BABYLON.Scene) scene.dispose();\n    if (engine && engine instanceof BABYLON.Engine) engine.dispose();\n    window.removeEventListener('beforeunload', this.onBeforeUnload);\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener('resize', this.onResizeWindow);\n    this.scene.dispose();\n    this.engine.dispose();\n    window.removeEventListener('beforeunload', this.onBeforeUnload);\n  }\n  onCanvasLoaded = (c: HTMLCanvasElement) => {\n    if (c !== null) {\n      this.canvas = c;\n      this.resize();\n    }\n  };\n\n  resize = () => {\n    this.canvas.width = this.canvas.parentElement.offsetWidth;\n    this.canvas.height = this.canvas.parentElement.offsetHeight;\n    if (this.sceneMountReturn && this.sceneMountReturn.resizeEvents) {\n      for (let i = 0; i < this.sceneMountReturn.resizeEvents.length; i++) {\n        this.sceneMountReturn.resizeEvents[i]();\n      }\n    }\n  };\n\n  render() {\n    return (\n      <canvas\n        // {...this.props}\n        ref={this.onCanvasLoaded}\n        width={'100%'}\n        height={'100%'}\n      />\n    );\n  }\n}\n","import * as BABYLON from 'babylonjs';\n\nexport type Bounds = {\n  x: MinMaxNumber;\n  y: MinMaxNumber;\n  z: MinMaxNumber;\n  width: number;\n  height: number;\n  depth: number;\n};\n\nexport type MinMaxNumber = {\n  min: number;\n  max: number;\n};\n\nexport default class BasicUtils {\n  public static generateRandomString(length: Number): string {\n    const range = '0123456789QWERTZUIOPLKJHGFDSAYXCVBNMqwertzuioplkjhgfdsayxcvbnm';\n    let s = '';\n    for (let i = 0; i < length; i++) {\n      const random = Math.floor(Math.random() * range.length);\n      s += range[random];\n    }\n    return s;\n  }\n\n  public static findFirstChild(name: string, container: BABYLON.TransformNode, directDescendantsOnly?: boolean): BABYLON.TransformNode {\n    const children = container.getChildTransformNodes(directDescendantsOnly);\n    const index = name.indexOf(':');\n    if (index > 0) {\n      const firstName = name.substring(0, index);\n      const lastName = name.substring(index + 1);\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i];\n        if (child.name === firstName) return this.findFirstChild(lastName, child, directDescendantsOnly);\n      }\n    } else {\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i];\n        if (child.name === name) return child;\n      }\n    }\n\n    return null;\n  }\n\n  public static getBounds(node: BABYLON.Node): Bounds {\n    const bounds = {\n      x: {\n        min: 0,\n        max: 0\n      },\n      y: {\n        min: 0,\n        max: 0\n      },\n      z: {\n        min: 0,\n        max: 0\n      },\n      width: 0,\n      height: 0,\n      depth: 0\n    };\n\n    let firstChildIsMesh = false;\n    if (node instanceof BABYLON.AbstractMesh) {\n      const min = node.getBoundingInfo().minimum;\n      const max = node.getBoundingInfo().maximum;\n\n      bounds.x.min = min.x;\n      bounds.y.min = min.y;\n      bounds.z.min = min.z;\n      bounds.x.max = max.x;\n      bounds.y.max = max.y;\n      bounds.z.max = max.z;\n\n      firstChildIsMesh = true;\n    }\n\n    const children = node.getChildMeshes();\n    for (let i = 0; i < children.length; i++) {\n      const m = children[i];\n      if (!m.isEnabled()) continue;\n      const min = m.getBoundingInfo().minimum;\n      const max = m.getBoundingInfo().maximum;\n\n      if (i < 1 && !firstChildIsMesh) {\n        bounds.x.min = min.x;\n        bounds.y.min = min.y;\n        bounds.z.min = min.z;\n        bounds.x.max = max.x;\n        bounds.y.max = max.y;\n        bounds.z.max = max.z;\n      } else {\n        if (bounds.x.min > min.x) bounds.x.min = min.x;\n        if (bounds.y.min > min.y) bounds.y.min = min.y;\n        if (bounds.z.min > min.z) bounds.z.min = min.z;\n        if (bounds.x.max < max.x) bounds.x.max = max.x;\n        if (bounds.y.max < max.y) bounds.y.max = max.y;\n        if (bounds.z.max < max.z) bounds.z.max = max.z;\n      }\n    }\n\n    bounds.width = Math.abs(bounds.x.max - bounds.x.min);\n    bounds.height = Math.abs(bounds.y.max - bounds.y.min);\n    bounds.depth = Math.abs(bounds.z.max - bounds.z.min);\n\n    return bounds;\n  }\n\n  public static copy(root: BABYLON.TransformNode, name: string, parent?: BABYLON.TransformNode): BABYLON.TransformNode {\n    let copy = null;\n    if (root instanceof BABYLON.Mesh) {\n      copy = root.createInstance(name);\n      copy.parent = parent;\n    } else {\n      copy = root.clone(null, parent, true);\n      copy.name = name;\n    }\n\n    const children = root.getChildTransformNodes(true);\n    for (let i = 0; i < children.length; i++) {\n      const element = children[i];\n      this.copy(element, element.name, copy);\n    }\n    return copy;\n  }\n\n  public static clone(root: BABYLON.TransformNode, name?: string, parent?: BABYLON.TransformNode): BABYLON.TransformNode {\n    const clone = root.clone(root.name, parent || root.parent, true);\n    clone.name = name || root.name;\n    clone.id = root.id;\n    const children = root.getChildTransformNodes(true);\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      this.clone(child, undefined, clone);\n    }\n    return clone;\n  }\n\n  public static color(r: number, g: number, b: number) {\n    return new BABYLON.Color3(r / 255, g / 255, b / 255);\n  }\n\n  /**\n   * Checks if a given Point is inside a Poly\n   *\n   * @param poly Poly of Vector2 elements\n   * @param point Vector2 to check\n   * @return true if the Point is inside the Poly\n   */\n  public static isPointInPoly(\n    poly: Array<{\n      x: number;\n      y: number;\n    }>,\n    point: {\n      x: number;\n      y: number;\n    }\n  ): boolean {\n    if (poly.length < 3) return false;\n    let i = 0,\n      j = 0,\n      l = poly.length;\n    let c = false;\n    for (i = 0, j = l - 1; i < l; j = i++) {\n      if (poly[i].y > point.y != poly[j].y > point.y && point.x < ((poly[j].x - poly[i].x) * (point.y - poly[i].y)) / (poly[j].y - poly[i].y) + poly[i].x)\n        c = !c;\n    }\n    return c;\n  }\n}\n","import * as BABYLON from \"babylonjs\";\nimport BasicUtils from \"./BasicUtils\";\nimport Scene from \"page/View/Scene\";\n\nexport default class MaterialUtils {\n    /**\n     * Attach all default Materials to the Scene\n     */\n    public static initialize(): void {\n        const scene = Scene.CURRENT_SCENE;\n        // Import Textures\n        const wood = new BABYLON.Texture(\"/texture/wood.jpg\", Scene.CURRENT_SCENE);\n        // Code = Radiant ; Editor = Degrees\n        // X Radiant = X * (180/π) Degrees\n        // X Degrees = X * (π/180) Radiant\n        wood.wAng = 90 * (Math.PI / 180);\n        wood.uScale = 0.5;\n        const metal = new BABYLON.Texture(\"texture/metal.jpg\", Scene.CURRENT_SCENE);\n        metal.level = 2;\n        const laptop = new BABYLON.Texture(\"texture/laptop.png\", Scene.CURRENT_SCENE)\n        const carpet = new BABYLON.Texture(\"texture/carpet.jpg\", Scene.CURRENT_SCENE)\n        carpet.uScale = 7.5\n        carpet.vScale = 7.5\n        // Import Materials\n        {\n            const material = new BABYLON.PBRMaterial(\"_metal\", scene);\n            material.albedoColor = BasicUtils.color(155, 155, 160);\n            material.metallic = 0.9;\n            material.roughness = 0.1;\n            material.backFaceCulling = false;\n            material.clearCoat.isEnabled = true;\n            material.clearCoat.intensity = 0.2;\n            material.clearCoat.roughness = 0.1;\n            material.clearCoat.indexOfRefraction = 3;\n            material.specularIntensity = 0.15;\n            material.directIntensity = 1;\n            material.enableSpecularAntiAliasing = true;\n            material.albedoTexture = metal;\n            //material.freeze();\n        }\n        {\n            const material = new BABYLON.PBRMaterial(\"_wood\", scene);\n            // material.albedoColor = BasicUtils.color(79, 46, 5);\n            material.albedoColor = BasicUtils.color(255, 255, 255);\n            material.metallic = 0.2;\n            material.roughness = 0.5;\n            material.backFaceCulling = false;\n            material.specularIntensity = 0.15;\n            material.directIntensity = 1;\n            material.enableSpecularAntiAliasing = true;\n            material.albedoTexture = wood;\n            //material.freeze();\n        }\n        {\n            const material = new BABYLON.PBRMaterial(\"_laptop\", scene);\n            // material.albedoColor = BasicUtils.color(79, 46, 5);\n            material.albedoColor = BasicUtils.color(255, 255, 255);\n            material.metallic = 0.2;\n            material.roughness = 0.5;\n            material.backFaceCulling = false;\n            material.specularIntensity = 0.15;\n            material.directIntensity = 1;\n            material.enableSpecularAntiAliasing = true;\n            material.albedoTexture = laptop;\n            //material.freeze();\n        }\n        {\n            const material = new BABYLON.PBRMaterial(\"_carpet\", scene)\n            // material.albedoColor = BasicUtils.color(79, 46, 5);\n            material.albedoColor = BasicUtils.color(150, 150, 150);\n            material.metallic = 0;\n            material.roughness = 0.9;\n            material.backFaceCulling = false;\n            material.specularIntensity = 0.15;\n            material.directIntensity = 1;\n            material.enableSpecularAntiAliasing = true;\n            material.albedoTexture = carpet;\n            //material.freeze();\n        }\n    }\n}\n","import * as BABYLON from 'babylonjs';\nimport 'babylonjs-loaders';\nimport BasicUtils, { Bounds } from './BasicUtils';\nimport axios from 'axios';\nimport Scene from 'page/View/Scene';\n\nexport type ImportSettings = {\n  scaling?: BABYLON.Vector3;\n  rotation?: BABYLON.Vector3;\n  shadowGenerators?: BABYLON.ShadowGenerator[];\n  mirrors?: BABYLON.AbstractMesh[];\n  pluginExtension?: string;\n};\n\nexport type LoadReturn = {\n  bounds: Bounds;\n  model: BABYLON.TransformNode;\n};\n\nexport default class LoaderUtils {\n  private static defaultSettings: ImportSettings = {\n    scaling: new BABYLON.Vector3(1, 1, 1),\n    rotation: new BABYLON.Vector3(0, 0, 0),\n    pluginExtension: '.gltf'\n  };\n\n  public static initialize(): void {\n    if (LoaderUtils.loadedNode && !LoaderUtils.loadedNode.isDisposed()) LoaderUtils.loadedNode.dispose();\n    LoaderUtils.loadedNode = new BABYLON.TransformNode('_loader', Scene.CURRENT_SCENE);\n    LoaderUtils.loadedNode.setEnabled(false);\n\n    LoaderUtils.loading.clear();\n    LoaderUtils.loaded.clear();\n  }\n\n  private static loading = new Map<string, Array<{ callback: (r: LoadReturn) => void; error: () => void }>>();\n  private static loaded = new Map<string, BABYLON.TransformNode>();\n  private static loadedNode: BABYLON.TransformNode = null;\n\n  public static load(obj: string, callback?: (r: LoadReturn) => void, error?: () => void): void {\n    // Check if model has already been loaded\n    if (LoaderUtils.loaded.has(obj)) {\n      const model = LoaderUtils.loaded.get(obj);\n      const r = {\n        bounds: BasicUtils.getBounds(model),\n        model: BasicUtils.clone(model)\n      };\n      if (callback) callback(r);\n    }\n    // Check if model is loading\n    else if (LoaderUtils.loading.has(obj)) {\n      LoaderUtils.loading.get(obj).push({ callback: callback, error: error });\n    }\n    // Load model\n    else {\n      LoaderUtils.loading.set(obj, []);\n      const scaling = LoaderUtils.defaultSettings.scaling;\n      const rotation = LoaderUtils.defaultSettings.rotation;\n      const pluginExtension = LoaderUtils.defaultSettings.pluginExtension;\n\n      var model = new BABYLON.TransformNode(obj, Scene.CURRENT_SCENE);\n\n      console.log('load', obj);\n\n      axios\n        .get(obj, {\n          withCredentials: true,\n          headers: {\n            jwt: window.localStorage.getItem('jwt')\n          }\n        })\n        .then(response => {\n          const text = JSON.stringify(response.data);\n          const materialsToDispose = new Map<number, BABYLON.Material>();\n          BABYLON.SceneLoader.ImportMesh(\n            '',\n            '',\n            'data:' + text,\n            Scene.CURRENT_SCENE,\n            (_meshes, _particleSystems, _skeletons, _animationGroups) => {\n              // console.log('newMeshes', _meshes)\n              for (var i = 0; i < _meshes.length; i++) {\n                const m = _meshes[i];\n                if (i < 1) {\n                  m.parent = model;\n                  m.position = BABYLON.Vector3.Zero();\n                  m.scaling = scaling;\n                  m.rotation = rotation;\n                }\n\n                m.cullingStrategy = BABYLON.Mesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY;\n\n                // remove duplicated materials\n                if (m.material) {\n                  m.material.backFaceCulling = false;\n                  for (let i = 0; i < Scene.CURRENT_SCENE.materials.length; i++) {\n                    const material = Scene.CURRENT_SCENE.materials[i];\n                    if (material.name === '_' + m.material.name && material.uniqueId !== m.material.uniqueId) {\n                      materialsToDispose.set(m.material.uniqueId, m.material);\n                      m.material = material;\n                      break;\n                    }\n                  }\n                }\n              }\n\n              materialsToDispose.forEach((_value, _key) => {\n                _value.dispose();\n              });\n\n              const t = model.getChildTransformNodes();\n              for (let i = 0; i < t.length; i++) {\n                const e = t[i];\n                e.rotation = BABYLON.Vector3.Zero();\n              }\n\n              model.parent = LoaderUtils.loadedNode;\n\n              LoaderUtils.loaded.set(obj, model);\n\n              const r = {\n                bounds: BasicUtils.getBounds(model),\n                model: BasicUtils.clone(model)\n              };\n\n              console.log('Loaded ' + obj, r);\n\n              if (callback)\n                setTimeout(() => {\n                  callback(r);\n                });\n\n              const asyncCallbacks = LoaderUtils.loading.get(obj);\n              for (let i = 0; i < asyncCallbacks.length; i++) {\n                const asyncCallback = asyncCallbacks[i];\n                const ar = {\n                  bounds: r.bounds,\n                  model: BasicUtils.clone(model)\n                };\n                if (asyncCallback.callback)\n                  setTimeout(() => {\n                    asyncCallback.callback(ar);\n                  });\n              }\n              LoaderUtils.loading.delete(obj);\n            },\n            undefined,\n            undefined,\n            pluginExtension\n          );\n        })\n        .catch(reason => {\n          console.log('Unable to load ' + obj, reason);\n          if (error)\n            setTimeout(() => {\n              error();\n            });\n          const asyncCallbacks = LoaderUtils.loading.get(obj);\n          for (let i = 0; i < asyncCallbacks.length; i++) {\n            const asyncCallback = asyncCallbacks[i];\n            if (asyncCallback.error)\n              setTimeout(() => {\n                asyncCallback.error();\n              });\n          }\n          LoaderUtils.loading.delete(obj);\n          model.dispose();\n        });\n    }\n  }\n\n  public static isLoading() {\n    return LoaderUtils.loading.size > 0;\n  }\n}\n","export default class HighPerformanceQueue {\n  private static map = new Map<number, () => boolean>();\n  private static queue = new Array<number>();\n  private static isRunning = false;\n\n  public static push(uniqueId: number, f: () => boolean) {\n    if (HighPerformanceQueue.map.has(uniqueId)) {\n      HighPerformanceQueue.map.set(uniqueId, f);\n    } else {\n      HighPerformanceQueue.map.set(uniqueId, f);\n      HighPerformanceQueue.queue.push(uniqueId);\n    }\n    HighPerformanceQueue.call();\n  }\n\n  private static call() {\n    const id = HighPerformanceQueue.queue.shift();\n    const f = HighPerformanceQueue.map.get(id);\n    HighPerformanceQueue.map.delete(id);\n    if (!HighPerformanceQueue.isRunning && f) {\n      HighPerformanceQueue.isRunning = true;\n      try {\n        f();\n      } catch (e) {\n        console.error(e);\n      }\n      setTimeout(HighPerformanceQueue.call, 100);\n      HighPerformanceQueue.isRunning = false;\n    }\n  }\n}\n","import * as BABYLON from \"babylonjs\";\nimport Scene from \"page/View/Scene\";\nimport HighPerformanceQueue from \"../helper/HighPerformanceQueue\";\nimport { AbstractMesh, GroundBuilder, Vector2 } from \"babylonjs\";\n\nexport default class WorkbenchNode extends BABYLON.TransformNode {\n    constructor() {\n        super(\"WorkbenchNode\", Scene.CURRENT_SCENE);\n        this.bake();\n    }\n\n    public bake() {\n        HighPerformanceQueue.push(this.uniqueId, () => {\n            //#region Ground\n            const ground = BABYLON.MeshBuilder.CreateGround(\"ground\", { width: 1000, height: 1000 }, Scene.CURRENT_SCENE);\n            ground.position.y = -4 - 71 - 3;\n            ground.material = Scene.CURRENT_SCENE.getMaterialByName(\"_carpet\");\n            //#endregion\n            //#region Table\n            // materials/values\n            const plateScale = new BABYLON.Vector3(173, 4, 84);\n            const legScale = new BABYLON.Vector3(3, 71, 3);\n            const frameScale = new BABYLON.Vector3(160, legScale.x, 70);\n\n            let table : BABYLON.Mesh\n            {\n                const metal = Scene.CURRENT_SCENE.getMaterialByName(\"_metal\");\n                const wood = Scene.CURRENT_SCENE.getMaterialByName(\"_wood\");\n                const meshes = [] as BABYLON.Mesh[];\n\n                // faces UV Vector {uStart, vStart, uEnd, vEnd}, bottom left x y, top right x y of sprite\n                // apply to all sides in array [0,1,2,3,4,5]\n                // make two versions, horizontal and vertical, frame and leg\n                // https://doc.babylonjs.com/how_to/createbox_per_face_textures_and_colors\n                const facesUv = [] as BABYLON.Vector4[];\n                for (let i = 0; i < 6; i++) {\n                    facesUv[i] = new BABYLON.Vector4(0.9, 0, 1, 1);\n                }\n                const options = {\n                    faceUV: facesUv,\n                    size: 1,\n                    wrap: true\n                };\n                // plate\n                const plate = BABYLON.Mesh.CreateBox(\"plate\", 1, Scene.CURRENT_SCENE);\n                plate.scaling = plateScale;\n                plate.position = new BABYLON.Vector3(plate.scaling.x / 2, 0, -plate.scaling.z / 2);\n                plate.material = wood;\n                meshes.push(plate);\n                // legs\n                legScale.y = legScale.y - legScale.x;\n                const leg0 = BABYLON.MeshBuilder.CreateBox(\"leg0\", options, Scene.CURRENT_SCENE);\n                //const leg0 = BABYLON.Mesh.CreateBox(\"leg0\", 1, Scene.CURRENT_SCENE);\n                leg0.scaling = legScale;\n                leg0.position = new BABYLON.Vector3(\n                    legScale.x / 2 + (plateScale.x - frameScale.x) / 2,\n                    -legScale.y / 2 - plateScale.y / 2 - legScale.x,\n                    -legScale.z / 2 - (plateScale.z - frameScale.z) / 2\n                );\n                leg0.material = metal;\n                meshes.push(leg0);\n                const leg1 = BABYLON.MeshBuilder.CreateBox(\"leg1\", options, Scene.CURRENT_SCENE);\n                leg1.scaling = legScale;\n                leg1.position = new BABYLON.Vector3(\n                    legScale.x / 2 + plateScale.x - legScale.x - (plateScale.x - frameScale.x) / 2,\n                    -legScale.y / 2 - plateScale.y / 2 - legScale.x,\n                    -legScale.z / 2 - (plateScale.z - frameScale.z) / 2\n                );\n                leg1.material = metal;\n                meshes.push(leg1);\n                const leg2 = BABYLON.MeshBuilder.CreateBox(\"leg2\", options, Scene.CURRENT_SCENE);\n                leg2.scaling = legScale;\n                leg2.position = new BABYLON.Vector3(\n                    legScale.x / 2 + (plateScale.x - frameScale.x) / 2,\n                    -legScale.y / 2 - plateScale.y / 2 - legScale.x,\n                    -legScale.z / 2 - plateScale.z + legScale.z + (plateScale.z - frameScale.z) / 2\n                );\n                leg2.material = metal;\n                meshes.push(leg2);\n                const leg3 = BABYLON.MeshBuilder.CreateBox(\"leg3\", options, Scene.CURRENT_SCENE);\n                leg3.scaling = legScale;\n                leg3.position = new BABYLON.Vector3(\n                    legScale.x / 2 + plateScale.x - legScale.x - (plateScale.x - frameScale.x) / 2,\n                    -legScale.y / 2 - plateScale.y / 2 - legScale.x,\n                    -legScale.z / 2 - plateScale.z + legScale.z + (plateScale.z - frameScale.z) / 2\n                );\n                leg3.material = metal;\n                meshes.push(leg3);\n                // frame\n                for (let i = 0; i < 6; i++) {\n                    facesUv[i] = new BABYLON.Vector4(0, 0.9, 1, 1);\n                }\n                options.faceUV = facesUv;\n                const frameOut = BABYLON.MeshBuilder.CreateBox(\"frameOut\", options, Scene.CURRENT_SCENE);\n                frameOut.scaling = frameScale;\n                const hole = BABYLON.MeshBuilder.CreateBox(\"hole\", options, Scene.CURRENT_SCENE);\n                hole.scaling = new BABYLON.Vector3(frameScale.x - frameScale.y * 2, frameScale.y, frameScale.z - frameScale.y * 2);\n                const fCSG = BABYLON.CSG.FromMesh(frameOut);\n                const hCSG = BABYLON.CSG.FromMesh(hole);\n                hole.dispose();\n                frameOut.dispose();\n                const frame = fCSG.subtract(hCSG).toMesh(\"frame\", metal, Scene.CURRENT_SCENE);\n                frame.position = new BABYLON.Vector3(plateScale.x / 2, -(plateScale.y + frameScale.y) / 2, -plateScale.z / 2);\n                meshes.push(frame);\n                // merge\n                table = BABYLON.Mesh.MergeMeshes(meshes, true, undefined, undefined, undefined, true);\n                table.name = \"table\";\n                table.parent = this;\n            }\n            //#endregion\n            //#region Chair\n            let chair : BABYLON.TransformNode\n            BABYLON.SceneLoader.ImportMesh(\"\", \"/gltf/chair/\", \"scene.gltf\", Scene.CURRENT_SCENE, newMeshes => {\n                chair = newMeshes[0].getChildTransformNodes()[0].getChildTransformNodes()[0].getChildTransformNodes()[0].getChildTransformNodes()[0];\n                chair.parent = this\n                newMeshes[0].dispose()\n                chair.name = 'chair'\n                chair.position = new BABYLON.Vector3(plateScale.x /2, -legScale.y, -legScale.y)\n                chair.rotationQuaternion = undefined\n                chair.rotation.y = 90 * (Math.PI/180)\n            });\n            //#endregion\n            //#region Deko\n            //#region Laptop\n            const lapScale = new BABYLON.Vector3(37, 1, 25);\n            \n            let laptop : BABYLON.Mesh\n            {\n                const laptopMat = Scene.CURRENT_SCENE.getMaterialByName(\"_laptop\");\n                const facesUv = [] as BABYLON.Vector4[];\n                const options = {\n                    faceUV: facesUv,\n                    size: 1,\n                    wrap: true\n                };\n                for (let i = 0; i < 6; i++) {\n                    facesUv[i] = new BABYLON.Vector4(0.5, 0, 0.5, 1);\n                }\n                facesUv[4] = new BABYLON.Vector4(0, 0.6, 0.5, 1);\n                options.faceUV = facesUv;\n                const lapBase = BABYLON.MeshBuilder.CreateBox(\"lapBase\", options, Scene.CURRENT_SCENE);\n                facesUv[4] = new BABYLON.Vector4(0.5, 0, 0.5, 1);\n                facesUv[1] = new BABYLON.Vector4(0.5, 0.6, 1, 1);\n                options.faceUV = facesUv;\n                const lapScreen = BABYLON.MeshBuilder.CreateBox(\"lapScreen\", options, Scene.CURRENT_SCENE);\n                lapBase.scaling = lapScale;\n                lapScreen.scaling = new BABYLON.Vector3(lapScale.x, lapScale.z, lapScale.y);\n                lapScreen.position = new BABYLON.Vector3(0, lapScale.z / 2 - 1, lapScale.z / 2 - Math.sin(22.5) * (lapScale.z / 2) - 1);\n                lapScreen.rotation.x = 22.5 * (Math.PI / 180);\n                lapBase.material = laptopMat;\n                lapScreen.material = laptopMat;\n                laptop = BABYLON.Mesh.MergeMeshes([lapBase, lapScreen], true);\n                laptop.name = \"laptop\";\n                laptop.parent = this;\n                laptop.position = new BABYLON.Vector3(plateScale.x / 2, plateScale.y / 2 + lapScale.y / 2, -plateScale.z / 2);\n            }\n            //#endregion\n            //#region Helmet\n            const helmetScale = 15;\n\n            let helmet : BABYLON.TransformNode\n            BABYLON.SceneLoader.ImportMesh(\"\", \"/gltf/\", \"DamagedHelmet.gltf\", Scene.CURRENT_SCENE, newMeshes => {\n                helmet = newMeshes[0].getChildTransformNodes()[0];\n                helmet.parent = this;\n                newMeshes[0].dispose();\n                helmet.scaling = new BABYLON.Vector3(helmetScale, helmetScale, helmetScale);\n                helmet.position = new BABYLON.Vector3(plateScale.x - 30, 15, -plateScale.z / 2);\n                helmet.rotationQuaternion = undefined;\n                helmet.rotation = new BABYLON.Vector3(90 * (Math.PI / 180), 215 * (Math.PI / 180), 0);\n            });\n            //#endregion\n            //#region Lamp\n            BABYLON.SceneLoader.ImportMesh(\"\", \"/gltf/desk_lamp/\", \"scene.gltf\", Scene.CURRENT_SCENE, newMeshes => {\n                const lamp = newMeshes[0].getChildTransformNodes()[0].getChildTransformNodes()[0].getChildTransformNodes()[0].getChildTransformNodes()[0];\n                lamp.parent = this;\n                newMeshes[0].dispose();\n                lamp.name = \"lamp\";\n                lamp.position = new BABYLON.Vector3(plateScale.x / 4, plateScale.y /2 , -plateScale.z / 3);\n                const light = new BABYLON.PointLight(\n                    \"lamp\",\n                    new BABYLON.Vector3(52, 28  , -28),\n                    Scene.CURRENT_SCENE\n                );\n                light.intensity = 5000\n                light.range = 10000;\n                light.parent = this\n                const shadowGenerator =  new BABYLON.ShadowGenerator(1024, light)\n                shadowGenerator.getShadowMap().renderList.push(table,laptop)\n                this.getChildMeshes().forEach(mesh => {\n                    shadowGenerator.getShadowMap().renderList.push(mesh)\n                })\n                this.getChildTransformNodes().forEach(node => {\n                    node.getChildMeshes().forEach(mesh => {\n                        \n                        console.log(mesh.name)\n                    })\n                    node.getChildTransformNodes().forEach(node2 => {\n                        node2.getChildMeshes().forEach(mesh => {\n                            shadowGenerator.getShadowMap().renderList.push(mesh)\n                            console.log(mesh.name)\n                        })\n                        node2.getChildTransformNodes().forEach(node3 => {\n                            node3.getChildMeshes().forEach(mesh => {\n                                shadowGenerator.getShadowMap().renderList.push(mesh)\n                                console.log(mesh.name)\n                            })\n                        })\n                    })\n                });\n                ground.receiveShadows = true;\n                shadowGenerator.usePoissonSampling = true;\n                //shadowGenerator.getShadowMap().renderList.push()\n            });\n            //#endregion\n            //#endregion\n            // Cheer ┳━┳ ヽ(ಠلಠ)ﾉ\n            return true;\n        });\n    }\n\n    dispose() {\n        super.dispose();\n    }\n}\n","import * as React from 'react';\nimport * as BABYLON from 'babylonjs';\nimport BabylonScene, { SceneEventArgs, SceneMountReturn } from '../../components/babylon/BabylonScene';\nimport 'pepjs';\nimport MaterialUtils from 'components/babylon/util/MaterialUtils';\nimport LoaderUtils from 'components/babylon/util/LoaderUtils';\n\n// Styles\nimport './Scene.scss';\nimport WorkbenchNode from 'components/babylon/node/WorkbenchNode';\n\n// ===================================================================\nexport default class Scene extends React.Component<{}, {}> {\n  public static CURRENT_SCENE: BABYLON.Scene;\n  private _scene: BABYLON.Scene;\n  private _initialized = false;\n  private _babylonScene = React.createRef<BabylonScene>();\n\n  private onSceneMount = (e: SceneEventArgs) => {\n    const sceneMountReturn: SceneMountReturn = {\n      resizeEvents: new Array<() => void>()\n    };\n    const { canvas, scene, engine } = e;\n    this._scene = scene;\n\n    Scene.CURRENT_SCENE = scene;\n\n    //#region Scene\n    // Set scene properties\n    const sceneColor: number = 0.4;\n    scene.clearColor = new BABYLON.Color4(sceneColor, sceneColor, sceneColor, 1);\n    scene.ambientColor = new BABYLON.Color3(0.1, 0.1, 0.1);\n\n    scene.fogMode = BABYLON.Scene.FOGMODE_LINEAR;\n    scene.fogColor = new BABYLON.Color3(sceneColor, sceneColor, sceneColor);\n    scene.fogStart = 1800;\n    scene.fogEnd = 2800;\n\n    // scene.animationsEnabled = false;\n    // scene.collisionsEnabled = false;\n    // scene.fogEnabled = true;\n    // scene.lensFlaresEnabled = false;\n    // scene.lightsEnabled = true;\n    // scene.particlesEnabled = false;\n    // scene.postProcessesEnabled = false;\n    // scene.probesEnabled = false;\n    // scene.texturesEnabled = true;\n    // scene.proceduralTexturesEnabled = true;\n    // scene.renderTargetsEnabled = true;\n    scene.shadowsEnabled = true;\n    // scene.skeletonsEnabled = false;\n    // scene.spritesEnabled = false;\n    //#endregion\n\n    //#region Cameras\n    let cameraDistance = 500;\n    const initialCameraDistance = cameraDistance + 300;\n\n    // Main Camera\n    const camera = new BABYLON.ArcRotateCamera('Camera', 0, 0, -10, new BABYLON.Vector3(86.5, 0, -50), scene);\n    camera.setPosition(new BABYLON.Vector3(0, 150, -cameraDistance));\n\n    camera.lowerBetaLimit = 0.01;\n    camera.upperBetaLimit = (Math.PI / 2) * 1.3;\n    camera.lowerRadiusLimit = 50;\n    //camera.upperBetaLimit = (Math.PI / 2) * 0.9;\n    //camera.lowerRadiusLimit = 150;\n\n    camera.cameraRotation = new BABYLON.Vector2(Math.PI, 0);\n    camera.layerMask = 0x0fffffff | 0x20000000;\n    \n    // More Cameras?\n\n    scene.activeCamera = camera;\n    //#endregion\n\n    //#region Lights\n    // Main Light\n    const light = new BABYLON.DirectionalLight('directional', new BABYLON.Vector3(-1, -1, 1), scene);\n    light.intensity = 1;\n    light.position = new BABYLON.Vector3(1000, 200, -1400);\n    //light.lightmapMode = BABYLON.Light.LIGHTMAP_SHADOWSONLY;\n\n    light.setEnabled(false)\n\n    // Back Light\n    const lightShadow = new BABYLON.DirectionalLight('directional-shadow', new BABYLON.Vector3(-1, -1.5, 1), scene);\n    lightShadow.intensity = 0.5;\n    lightShadow.position = new BABYLON.Vector3(1000, 200, -1400);\n    lightShadow.lightmapMode = BABYLON.Light.LIGHTMAP_SHADOWSONLY;\n\n    lightShadow.setEnabled(false)\n    // Back Light\n    const lightBack = new BABYLON.DirectionalLight('directional-back', new BABYLON.Vector3(1, -1, -1), scene);\n    lightBack.intensity = 0.66;\n    lightBack.position = new BABYLON.Vector3(-1000, 200, 1400);\n    // TODO CHANGE THIS FOR PRODUCTION MAYBE?\n    lightBack.setEnabled(false);\n    //#endregion\n\n    // Add shadows\n    const shadowGenerator = new BABYLON.ShadowGenerator(1024 * 1, lightShadow, true);\n    shadowGenerator.useBlurExponentialShadowMap = true;\n    shadowGenerator.blurScale = 1;\n    shadowGenerator.usePoissonSampling = true;\n\n    //#region post processing\n    const ssao = new BABYLON.SSAORenderingPipeline('ssaopipeline', scene, 1, [camera]);\n    //ssao.base = 0.7\n    //#endregion\n    //#region Prepare Utils\n    // Prepare MaterialUtils\n    MaterialUtils.initialize();\n    // Prepare LoaderUtils\n    LoaderUtils.initialize();\n    //#endregion\n\n    this._initialized = true;\n\n    //#region Chrome Fix\n    // TODO Fix Fix\n    const runChromeFix = () => {\n      if (navigator && /.*(Chrome).*/.test(navigator.userAgent)) {\n        // \"Fix\" first image not generated Bug\n        setTimeout(() => {\n          try {\n            BABYLON.Tools.CreateScreenshotUsingRenderTarget(\n              engine,\n              camera,\n              { width: 100, height: 100 },\n              (_data: string) => {\n                // Do Nothing\n              },\n              'image/png',\n              1,\n              false\n            );\n          } catch (e) {\n            setTimeout(() => {\n              runChromeFix();\n            }, 100);\n          }\n        }, 500);\n      }\n    };\n    //#endregion\n\n    const renderFirstTime = () => {\n      try {\n        scene.render();\n        // runChromeFix();\n      } catch (e) {\n        setTimeout(() => {\n          renderFirstTime();\n        }, 100);\n      }\n    };\n    renderFirstTime();\n\n    //#region RenderLoop\n    engine.runRenderLoop(() => {\n      try {\n        if (scene && document.hasFocus()) {\n          scene.render();\n        }\n      } catch (e) {\n        console.error(e);\n      }\n    });\n    //#endregion\n\n    //#region Workbench\n    new WorkbenchNode();\n    //#endregion\n\n    //#region Events\n    camera.attachControl(canvas, false);\n    // TODO Add Events\n    // canvas.addEventListener('pointerdown', onPointerDown, false);\n    // canvas.addEventListener('pointerup', onPointerUp, false);\n    // canvas.addEventListener('pointermove', onPointerMove, false);\n    // canvas.addEventListener('contextmenu', onContextMenu, false);\n\n    // TODO Remove Events\n    scene.onDispose = () => {\n      // canvas.removeEventListener('pointerdown', onPointerDown);\n      // canvas.removeEventListener('pointerup', onPointerUp);\n      // canvas.removeEventListener('pointermove', onPointerMove);\n      // canvas.removeEventListener('contextmenu', onContextMenu);\n    };\n    //#endregion\n\n    //#region Debug Views\n    canvas.addEventListener('keyup', (e: KeyboardEvent) => {\n      switch (e.key) {\n        case 'y':\n          for (let i = 0; i < scene.meshes.length; i++) {\n            const mesh = scene.meshes[i];\n            if (mesh.id.endsWith('_merged')) {\n              mesh.enableEdgesRendering(0.333);\n            }\n          }\n          break;\n        case '+':\n          scene.debugLayer.show();\n          break;\n      }\n    });\n    //#endregion\n\n    return sceneMountReturn;\n  };\n\n  render() {\n    return (\n      <div className=\"Scene\">\n        <BabylonScene\n          onSceneMount={this.onSceneMount}\n          engineOptions={{ preserveDrawingBuffer: true, stencil: true }}\n          sceneOptions={{ useClonedMeshMap: true }}\n          ref={this._babylonScene}\n        />\n      </div>\n    );\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport * as serviceWorker from './serviceWorker';\nimport Scene from 'page/View/Scene';\n\n// ==============================================================\nReactDOM.render(<Scene />, document.getElementById('root'));\nserviceWorker.unregister();\n"],"sourceRoot":""}